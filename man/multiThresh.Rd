% Generated by roxygen2 (4.0.1): do not edit by hand
\name{multiThresh}
\alias{multiThresh}
\title{multiThresh}
\usage{
multiThresh(Y, G = directG(dim(as.matrix(Y))), alpha = rep(1,
  dim(as.matrix(Y))[2]), blur = "direct", j0 = 3L, j1 = NA_integer_,
  eta = NA_real_, deg = 3L)
}
\arguments{
\item{Y}{The input multichannel signal in the form of an n by m matrix to denote the m separate channels with n observations in each channel. If a vector of size n is given, it is parsed as a single channel signal with n elements.}

\item{G}{The input multichannel blur matrix of size n by m (needs to be the same size as the signal input). This matrix dictates the form of blur present in each of the channels.}

\item{alpha}{A numeric vector, with m elements, specifying the level of long memory for the noise process within each channel of the form alpha = 2 - 2H, where H is the Hurst parameter. If alpha is a single element, that same element is repeated across all required channels.}

\item{j0}{The coarsest resolution level for the wavelet expansion.}

\item{j1}{The finest resolution level for the wavelet expansion. If unspecified, the function will compute all thresholds up to the maximum possible resolution level at j1 = log2(n) - 1.}

\item{eta}{The smoothing parameter. The default level is 2*sqrt(alpha_{l_*}).}

\item{deg}{The degree of the auxiliary polynomial for the Meyer wavelet.}
}
\value{
A numeric vector of the resolution level thresholds for the hard-thresholding nonlinear wavelet estimator from the multichannel model.
}
\description{
Computes the resolution level thresholds for the hard-thresholding estimate of the desired funnction f.
}
\details{
Given an input matrix of a multichannel signal (n rows and n columns) with m channels and n observations per channel, the function returns the required thresholds for the hard-thresholding estimator of the underlying function, f.
}
\examples{
library(mwaved)
# Simulate the multichannel doppler signal.
m <- 3
n <- 2^10
t <- (1:n)/n
signal <- (sqrt(t * (1 - t))) * sin((2 * pi * 1.05)/(t + 0.05))
signal <- signal * 2.4
signal <- matrix(rep(signal,m), nrow=n, ncol=m)
# Noise levels per channel
e <- rnorm(m*n)
# Create Gamma blur
alp <- c(0.5,0.75,1)
beta <- rep(0.25,3)
G <- sapply((1:n)/n, dgamma, shape = alp, scale = beta)
G <- t(G)
# Normalise the blur
Gmax <- matrix(rep(apply(G, 2, max), dim(G)[1]), ncol = m, nrow = n, byrow = T)
G <- G/Gmax
Gsum <- matrix(rep(apply(G, 2, sum), dim(G)[1]), ncol = m, nrow = n, byrow = T)
G <- G/Gsum
# Convolve the signal
X <- Re(mvfft(mvfft(G) * mvfft(signal), inverse = TRUE))/n
# Create error with custom signal to noise ratio
SNR <- c(10,15,20)
sigma <- sqrt(mean(X^2)) * 10^( -SNR/20 )
E <- matrix(rnorm(n*m, sd = sigma), ncol = m, nrow = n, byrow = T)
# Create noisy & blurred multichannel signal
Y <- X + E
thresh <- multiThresh(Y, G, blur = 'smooth')
}

