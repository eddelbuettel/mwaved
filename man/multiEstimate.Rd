% Generated by roxygen2 (4.0.1): do not edit by hand
\name{multiEstimate}
\alias{multiEstimate}
\title{multiEstimate}
\usage{
multiEstimate(Y, G = directG(dim(as.matrix(Y))), alpha = rep(1,
  dim(as.matrix(Y))[2]), blur = "direct", sigma = as.numeric(c()),
  j0 = 3L, j1 = NA_integer_, eta = NA_real_,
  thresh = multiThresh(as.matrix(Y), G = G, alpha = alpha, blur = blur, j0 =
  j0, j1 = j1, eta = eta, deg = 3L), shrinkType = "hard", deg = 3L)
}
\arguments{
\item{Y}{The input multichannel signal in the form of an n by m matrix to denote the m separate channels with n observations in each channel. If a vector of size n is given, it is parsed as a single channel signal with n elements.}

\item{G}{The input multichannel blur matrix of size n by m (needs to be the same dimensions and size as the signal input). This matrix dictates the form of blur present in each of the channels.}

\item{alpha}{A numeric vector, with m elements, specifying the level of long memory for the noise process within each channel of the form alpha = 2 - 2H, where H is the Hurst parameter. If alpha is a single element, that same element is repeated across all required channels.}

\item{blur}{A character string describing which deconvolution regime is to be applied.\itemize{
\item 'direct' (default): No deconvolution required and direct signal observed. This is captured when G is an n by m matrix with all entries being zero except the first row where all elements are one.
\item 'smooth': Indirect signal observed and the blurring kernel is of regular smooth blur type.
\item 'box.car': Indirect signal observed and the blurring kernel is of box car type.}}

\item{sigma}{A numeric vector with m elements that specifies the level of noise (standard deviation) in each channel.
The default method uses the Median Absolute Deviation of wavelet coefficients in the finest resolution (see \code{\link{multiSigma}}).}

\item{j0}{The coarsest resolution level for the wavelet expansion.}

\item{j1}{The finest resolution level for the wavelet expansion. If unspecified, the function will compute all thresholds up to the maximum possible resolution level at j1 = log2(n) - 1.}

\item{eta}{The smoothing parameter. The default level is 2*sqrt(alpha_{l_*}).}

\item{thresh}{A numeric vector specifying the thresholds to be used in the thresholded wavelet deconvolution estimator.}

\item{shrinkType}{A character string specifying the shrinkage type to use in estimation. Available choices are\itemize{
\item 'hard': Keep or kill shrinkage rule.
\item 'soft': Kill coefficients smaller than a threshold but uniformly trim coefficients otherwise.
\item 'garrote': Hybrid between the hard and soft regimes.
} See also the documentation for \code{\link{waveletThresh}} for formulae.}

\item{deg}{The degree of the auxiliary polynomial for the Meyer wavelet.}
}
\value{
A numeric vector of the estimate of the underlying signal of interest.
}
\description{
Estimates the underlying signal of interest from a multichannel noisy deconvolution model.
}
\details{
Function requires input of a noisy multichannel signal matrix, Y, which contains the information for each channel in each of the m columns. Optional inputs are a matrix, G, the same dimension as Y, that gives the multichannel blur information.
}
\examples{
library(mwaved)
# Simulate the multichannel doppler signal.
m <- 3
n <- 2^10
t <- (1:n)/n
signal <- makeDoppler(n)
# Noise levels per channel
e <- rnorm(m*n)
# Create Gamma blur
shape <- seq(from = 0.5, to = 1, length = m)
scale <- rep(0.25,m)
G <- gammaBlur(n, shape = shape, scale = scale)
# Convolve the signal
X <- blurSignal(signal, G)
# Create error with custom signal to noise ratio
SNR <- c(10,15,20)
sigma <- sqrt(mean(X^2)) * 10^( -SNR/20 )
E <- matrix(rnorm(n*m, sd = sigma), ncol = m, nrow = n, byrow = TRUE)
# Create noisy & blurred multichannel signal
Y <- X + E
# Estimate the underlying doppler signal
dopplerEstimate <- multiEstimate(Y, G = G, alpha = rep(1, m), blur = 'smooth')
# Plot the result and compare with truth
par(mfrow=c(2,1))
matplot(t, Y, type = 'l', main = 'Noisy multichannel signal')
plot(t, signal, type = 'l', lty = 2, main = 'True Doppler signal and estimate', col = 'red')
lines(t, dopplerEstimate)
}

