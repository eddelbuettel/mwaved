# Auxiliary file that contains the functions used in the simulations. 

#' @title Multichannel Gamma density blur
#' 
#' @param n An integer specifying the number of observations in each channel
#' @param shape A numeric vector specifying the shape parameter for each Gamma density in each channel
#' @param scale A numeric vector specifying the scale parameter for each Gamma density in each channel
#' 
#' @description Create blur of the regular smooth type generated from Gamma densities
#' 
#' @details A matrix of dimension n by m which contains a normalised (unit energy in each column) set of blur functions of regular smooth type, generated by a Gamma density. These Gamma densities are generated using the \code{\link{dgamma}} base R function and then normalised to have unit energy.
#' 
#' @return A n by m matrix of normalised Gamma blur.
#' 
#' @seealso \code{\link{dgamma}} for details of the Gamma density
#' @examples
#' n <- 128
#' m <- 3
#' shape <- seq(from = 0.5, to = 1, length = m)
#' scale <- rep(0.25,m)
#' 
#' blurMat <- gammaBlur(n, shape, scale)
#' matplot(blurMat, type = 'l', main = paste('Set of Gamma', m,'Gamma blur densities.'))
#' 
#' signal = makeLIDAR(n)
#' t = (1:n)/n
#' matplot(t, signal, type = 'l', main = 'LIDAR test signal')
#' blurredSignal <- blurSignal(signal, blurMat)
#' 
#' matplot(t, blurredSignal, type = 'l', main = 'Blurred LIDAR test signals')
#' @export
gammaBlur <- function(n, shape, scale) {
  if (length(shape) != length(scale)){
    warning("Dimension mismatch: Length of vectors for scale and shape parameters do not match")
  } 
  m <- length(shape)
  G <- sapply((1:n)/n, dgamma, shape = shape, scale = scale)
  
  if( is.null(dim(G)) ){
    G <- G/max(G)
    G <- G/sum(G)
    G <- as.matrix(G)
  } else {
    G <- G/(apply(G, 1, max))
    G <- G/(apply(G, 1, sum))
    G <- t(G)
  }
	return(G) 
}

#' @name makeSignals
#' @rdname makeSignals
#' @title Generate test signals for simulation
#' @description Generates test signals used the standard literature.
#' @param n An integer specifying the length of the desired signal.
#' @return A numeric vector of length n giving the desired test signal.
NULL

#' @rdname makeSignals
#' @examples
#' n <- 1024
#' signal <- makeLIDAR(n)
#' t = (1:n)/n
#' plot(t, signal, main = 'LIDAR test signal', type = 'l')
#' @export
makeLIDAR <- function(n) {
  t <- (1:n)/n
  y <- 0.7 * (1 * (t > 0.15) * (t < 0.65) + 1 * (t > 0.28) * (t < 0.48) + (133.33 * 
    t - 106.66) * (t > 0.8) * (t < 0.815) + (-133.33 * t + 110.6639) * (t > 
    0.815) * (t < 0.83) + (133.33 * t - 119.997) * (t > 0.9) * (t < 0.915) + 
    (-133.33 * t + 123.9969) * (t > 0.915) * (t < 0.93))
  return(y)
}

#' @rdname makeSignals
#' @examples
#' n <- 1024
#' signal <- makeLIDAR(n)
#' t = (1:n)/n
#' plot(t, signal, main = 'LIDAR test signal', type = 'l')
#' @export
makeBumps <- function(n) {
    t <- 1:n/n
    pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.4, 0.44, 0.65, 0.76, 0.78, 0.81)
    hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
    wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 
        0.005)
    y <- rep(0, n)
    for (j in 1:length(pos)) {
        y <- y + hgt[j]/(1 + abs((t - pos[j])/wth[j]))^4
    }
    y <- y * 1.8
  return(y)
}

#' @rdname makeSignals
#' @examples
#' n <- 1024
#' signal <- makeDoppler(n)
#' t = (1:n)/n
#' plot(t, signal, main = 'Doppler test signal', type = 'l')
#' @export
makeDoppler <- function(n) {
    t <- (1:n)/n
    y <- (sqrt(t * (1 - t))) * sin((2 * pi * 1.05)/(t + 0.05))
    y <- y * 2.4
    return(y)
}

#' @rdname makeSignals
#' @examples
#' n <- 1024
#' signal <- makeCusp(n)
#' t = (1:n)/n
#' plot(t, signal, main = 'Cusp test signal', type = 'l')
#' @export
makeCusp <- function(n) {
  t <- (1:n)/n
  y <- 2.4 * sqrt(abs(t - 0.37))
  return(y)
}

#' @rdname makeSignals
#' @examples
#' n <- 1024
#' signal <- makeBlocks(n)
#' t = (1:n)/n
#' plot(t, signal, main = 'Blocks test signal', type = 'l')
#' @export
makeBlocks <- function(n) {
    t <- (1:n)/n
    pos = c(0.1, 0.13, 0.15, 0.23, 0.25, 0.4, 0.44, 0.65, 0.76, 0.78, 0.81)
    hgt = c(4, (-5), 3, (-4), 5, (-4.2), 2.1, 4.3, (-3.1), 2.1, (-4.2))
    y <- rep(0, n)
    for (j in 1:length(pos)) {
        y = y + (1 + sign(t - pos[j])) * (hgt[j]/2)
    }
    return(y)
}

#' @title Blur an input signal 
#' 
#' @description An input signal is blurred by a set of functions to obtain a blurred multichannel signal.
#' 
#' @param signal A numeric vector of length n of the signal of interest
#' @param G An n by m matrix of blur functions to be applied to the signal of interest.
#' 
#' @details Applies the convolution operator to the signal of interest with each column of G to create a multichannel blurred signal. This operation is done in the Fourier domain using the base R fft transforms.
#' @examples
#' n <- 1024
#' m <- 3
#' blur <- gammaBlur(n, shape = seq(from = 0.5, to = 1, length = m), scale = rep(0.25, m))
#' t = (1:n)/n
#' signal <- makeLIDAR(n)
#' par(mfrow = c(2,1))
#' plot(t, signal, type = 'l', main = 'Direct LIDAR signal')
#' indirectSignal <- blurSignal(signal, blur)
#' matplot(t, indirectSignal, type = 'l', main = 'Set of blurred LIDAR signals')
#' @export
blurSignal <- function(signal, G) {
  n <- length(signal)
  if( dim(G)[1] != n)
    stop("Dimension mismatch: Number of rows in G needs to match length of signal")
  m <- dim(G)[2]
  signal <- matrix(rep(signal, m), ncol = m, nrow = n)
  y <- Re(mvfft(mvfft(signal) * mvfft(G), inverse = TRUE))/n
  y
}

# multiNoise <- function(n, alpha, SNR = 15) {
#   IID <- TRUE
#   # Simulate independent Gaussian noise by default
#   if( is.integer(alpha) && alpha > 0 ){
#     m <- alpha
#     noise <- matrix(rnorm(n * alpha), ncol = m)
#   }
# }
