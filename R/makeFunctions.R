# Auxiliary file that contains the functions used in the simulations. 

#' @title Multichannel Gamma density blur
#' 
#' @param n An integer specifying the number of observations in each channel
#' @param shape A numeric vector specifying the shape parameter for each Gamma density in each channel
#' @param scale A numeric vector specifying the scale parameter for each Gamma density in each channel
#' 
#' @description Create blur of the regular smooth type generated from Gamma densities
#' 
#' @details A matrix of dimension n by m which contains a normalised (unit energy in each column) set of blur functions of regular smooth type, generated by a Gamma density. These Gamma densities are generated using the \code{\link{dgamma}} base R function and then normalised to have unit energy.
#' 
#' @return A n by m matrix of normalised Gamma blur.
#' 
#' @seealso \code{\link{dgamma}} for details of the Gamma density
#' @examples
#' n <- 128
#' m <- 3
#' shape <- seq(from = 0.5, to = 1, length = m)
#' scale <- rep(0.25,m)
#' 
#' blurMat <- gammaBlur(n, shape, scale)
#' matplot(blurMat, type = 'l', main = paste('Set of Gamma', m,'Gamma blur densities.'))
#' 
#' signal = makeLIDAR(n)
#' t = (1:n)/n
#' matplot(t, signal, type = 'l', main = 'LIDAR test signal')
#' blurredSignal <- blurSignal(signal, blurMat)
#' 
#' matplot(t, blurredSignal, type = 'l', main = 'Blurred LIDAR test signals')
#' @export
gammaBlur <- function(n, shape, scale) {
  if (length(shape) != length(scale)){
    warning("Dimension mismatch: Length of vectors for scale and shape parameters do not match")
  } 
  m <- length(shape)
  G <- sapply((1:n)/n, dgamma, shape = shape, scale = scale)
  
  if( is.null(dim(G)) ){
    G <- G/max(G)
    G <- G/sum(G)
    G <- as.matrix(G)
  } else {
    G <- G/(apply(G, 1, max))
    G <- G/(apply(G, 1, sum))
    G <- t(G)
  }
	return(G) 
}

#' @name makeSignals
#' @rdname makeSignals
#' @title Generate test signals for simulation
#' @description Generates test signals used the standard literature.
#' @param n An integer specifying the length of the desired signal.
#' @return A numeric vector of length n giving the desired test signal.
NULL

#' @rdname makeSignals
#' @examples
#' n <- 1024
#' signal <- makeLIDAR(n)
#' t = (1:n)/n
#' plot(t, signal, main = 'LIDAR test signal', type = 'l')
#' @export
makeLIDAR <- function(n) {
  t <- (1:n)/n
  y <- 0.7 * (1 * (t > 0.15) * (t < 0.65) + 1 * (t > 0.28) * (t < 0.48) + (133.33 * 
    t - 106.66) * (t > 0.8) * (t < 0.815) + (-133.33 * t + 110.6639) * (t > 
    0.815) * (t < 0.83) + (133.33 * t - 119.997) * (t > 0.9) * (t < 0.915) + 
    (-133.33 * t + 123.9969) * (t > 0.915) * (t < 0.93))
  return(y)
}

#' @rdname makeSignals
#' @examples
#' n <- 1024
#' signal <- makeLIDAR(n)
#' t = (1:n)/n
#' plot(t, signal, main = 'LIDAR test signal', type = 'l')
#' @export
makeBumps <- function(n) {
    t <- 1:n/n
    pos <- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.4, 0.44, 0.65, 0.76, 0.78, 0.81)
    hgt <- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)
    wth <- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 
        0.005)
    y <- rep(0, n)
    for (j in 1:length(pos)) {
        y <- y + hgt[j]/(1 + abs((t - pos[j])/wth[j]))^4
    }
    y <- y * 1.8
  return(y)
}

#' @rdname makeSignals
#' @examples
#' n <- 1024
#' signal <- makeDoppler(n)
#' t = (1:n)/n
#' plot(t, signal, main = 'Doppler test signal', type = 'l')
#' @export
makeDoppler <- function(n) {
    t <- (1:n)/n
    y <- (sqrt(t * (1 - t))) * sin((2 * pi * 1.05)/(t + 0.05))
    y <- y * 2.4
    return(y)
}

#' @rdname makeSignals
#' @examples
#' n <- 1024
#' signal <- makeCusp(n)
#' t = (1:n)/n
#' plot(t, signal, main = 'Cusp test signal', type = 'l')
#' @export
makeCusp <- function(n) {
  t <- (1:n)/n
  y <- 2.4 * sqrt(abs(t - 0.37))
  return(y)
}

#' @rdname makeSignals
#' @examples
#' n <- 1024
#' signal <- makeBlocks(n)
#' t = (1:n)/n
#' plot(t, signal, main = 'Blocks test signal', type = 'l')
#' @export
makeBlocks <- function(n) {
    t <- (1:n)/n
    pos = c(0.1, 0.13, 0.15, 0.23, 0.25, 0.4, 0.44, 0.65, 0.76, 0.78, 0.81)
    hgt = c(4, (-5), 3, (-4), 5, (-4.2), 2.1, 4.3, (-3.1), 2.1, (-4.2))
    y <- rep(0, n)
    for (j in 1:length(pos)) {
        y = y + (1 + sign(t - pos[j])) * (hgt[j]/2)
    }
    return(y)
}

#' @title Blur an input signal 
#' 
#' @description An input signal is blurred by a set of functions to obtain a blurred multichannel signal.
#' 
#' @param signal A numeric vector of length n of the signal of interest
#' @param G An n by m matrix of blur functions to be applied to the signal of interest.
#' 
#' @details Applies the convolution operator to the signal of interest with each column of G to create a multichannel blurred signal. This operation is done in the Fourier domain using the base R fft transforms.
#' @examples
#' n <- 1024
#' m <- 3
#' blur <- gammaBlur(n, shape = seq(from = 0.5, to = 1, length = m), scale = rep(0.25, m))
#' t = (1:n)/n
#' signal <- makeLIDAR(n)
#' par(mfrow = c(2,1))
#' plot(t, signal, type = 'l', main = 'Direct LIDAR signal')
#' indirectSignal <- blurSignal(signal, blur)
#' matplot(t, indirectSignal, type = 'l', main = 'Set of blurred LIDAR signals')
#' @export
blurSignal <- function(signal, G) {
  n <- length(signal)
  if( dim(G)[1] != n)
    stop("Dimension mismatch: Number of rows in G needs to match length of signal")
  m <- dim(G)[2]
  signal <- matrix(rep(signal, m), ncol = m, nrow = n)
  y <- Re(mvfft(mvfft(signal) * mvfft(G), inverse = TRUE))/n
  y
}

#' @title Generate multichannel noise
#' @description Generate a matrix of multichannel (possibly long memory) noise variables
#' @param n An integer specifying the number of obsevations per channel.
#' @param alpha A vector specifying the dependence level in each channel.  
#' @param sigma A vector giving the noise levels (standard deviation) for each channel in the multichannel model (see details).
#' @param ... Additional arguments to pass to the \code{fracdiff} package to tightly control the long memory noise.
#' @details Generates a n by m matrix of noise variables. Long memory variables can be generated by the use of the optional \code{fracdiff} package (if installed). The dependence is specified using the \code{alpha} parameter where \code{alpha} = 2 - 2H where H = Hurst parameter. Long memory is ensured when alpha is between 0 and 1 (H between 1/2 and 1). 
#' @seealso \code{\link{sigmaSNR}}
#' @examples
#' n <- 1024
#' m <- 3
#' signal <- makeLIDAR(n)
#' blur <- gammaBlur(n, c(0.5, 0.75, 1), rep(1, m))
#' X <- blurSignal(signal, blur)
#' SNR <- 10*1:3
#' sigma <- sigmaSNR(X, SNR)
#' E <- multiNoise(n, sigma, alpha = c(0.5, 0.75, 1))
#' matplot(X + E, type = 'l')
#' @export
multiNoise <- function(n, sigma = 1, alpha = length(sigma), ...) {
  # Simulate independent Gaussian noise by default
  if( is.integer(alpha) && alpha > 0 ){
    m <- alpha
    noise <- matrix(rnorm(n * alpha, sd = sigma), ncol = m, byrow = TRUE)
  } else {
    if( require(fracdiff) ){
      d <- (1 - alpha)/2
      noise <- sapply(1:m, function(x,y) y[x] * fracdiff.sim(n, d = d[x])$series, y = sigma)
    } else {
      m <- length(sigma)
      noise <- matrix(rnorm(n * alpha, sd = sigma), ncol = m, byrow = TRUE)
    }
  }
  noise
}

#' @title Determine noise scale from \bold{S}ignal to \bold{N}oise \bold{R}atios
#' @param signal Noisefree multichannel input signal
#' @param SNR Desired \bold{S}ignal to \bold{N}oise \bold{R}atio for each channel.
#' @details TBA
#' @return A numeric vector giving the scales (channel level noise standard deviations) to achieve the desired SNR.
#' @seealso \code{\link{multiNoise}} \code{\link{multiSigma}}
#' @examples
#' n <- 1024
#' m <- 3
#' signal <- makeLIDAR(n)
#' blur <- gammaBlur(n, c(0.5, 0.75, 1), rep(1, m))
#' X <- blurSignal(signal, blur)
#' SNR <- 10*1:3
#' sigma <- sigmaSNR(X, SNR)
#' E <- multiNoise(n, sigma)
#' sigmaEst <- multiSigma(E)
#' @export
sigmaSNR <- function(signal, SNR) {
  Y <- as.matrix(signal)
  n <- dim(Y)[1]
  m <- dim(Y)[2]
  if( m > 1 && length(SNR) == 1 ){
    # Repeat SNR across all channels
    sigma <- sqrt(apply(Y^2, 2, mean)) * 10^(-SNR/20)
  } else {
    if( length(SNR) >= m ) {
      if( length(SNR) == m ){
        sigma <- sqrt(apply(Y^2, 2, mean)) * 10^(-SNR/20)
      } else {
        warning('Dimension mismatch: Length of SNR too long and must match number of columns of input signal. Only first m elements used.')
        sigma <- sqrt(apply(Y^2, 2, mean)) * 10^(-SNR[1:m]/20)
      }
    } else {
      # Repeat first element of SNR on all channels
      warning("Dimension mismatch: Length of SNR must match number of columns of input signal. Only first element of SNR used")
      sigma <- sqrt(apply(Y^2, 2, mean)) * 10^(-SNR[1]/20)
    }
  }
  sigma
}